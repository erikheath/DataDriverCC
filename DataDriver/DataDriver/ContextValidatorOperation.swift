//
//  ContextValidatorOperation.swift
//  DataDriver
//
//  Created by ERIKHEATH A THOMAS on 3/15/16.
//  Copyright Â© 2016 Curated Cocoa LLC. All rights reserved.
//

import Foundation
import CoreData

import CoreData

struct ContextValidatorCondition: OperationCondition {

    static let name = "ContextValidator"

    static let isMutuallyExclusive = false

    let partitionOp: RemoteStoreRequestOperation

    init(partitionOp: RemoteStoreRequestOperation) {
        self.partitionOp = partitionOp
    }

    func dependencyForOperation(operation: Operation) -> NSOperation? {
        guard let operation = operation as? RemoteStoreRequestOperation else { return nil }

        return ContextValidatorOperation(partitionOp: operation)
    }

    func evaluateForOperation(operation: Operation, completion:OperationConditionResult -> Void) {
        switch self.partitionOp.updatesValidated  {
        case true:
            completion(.Satisfied)

        default:
            let error = NSError(code: .ConditionFailed, userInfo: [
                OperationConditionKey: self.dynamicType.name
                ])

            completion(.Failed(error))
        }
    }
}


class ContextValidatorOperation: Operation {

    var dataConditioned: Bool = false

    let partitionOp: RemoteStoreRequestOperation

    init(partitionOp: RemoteStoreRequestOperation) {
        self.partitionOp = partitionOp
    }

    override func execute() {
        do {
            try self.saveContexts()
            self.partitionOp.updatesValidated = true
        } catch {
            // The save failed or has left the context in an inconsistent state.
            self.partitionOp.updatesValidated = false
        }
    }

    /**
     Attempts to save the passed in context, optionally attempting to fix validation errors if any are encountered.

     - Throws: If errors are encountered or if they can not be repaired, throws the error generated by trying to save the context.
     */
    func saveContext( context: NSManagedObjectContext, fixValidationErrors: Bool) throws {

        var saveError: ErrorType? = nil

        context.performBlockAndWait { () -> Void in

            var caughtError: NSError? = nil

            do {
                if context.hasChanges {
                    try context.save()
                    return
                } else {
                    return
                }
            } catch {
                caughtError = error as NSError
            }

            do {
                if caughtError != nil && fixValidationErrors == true {
                    try self.processValidationErrors(caughtError!, context: context)
                    try context.save()
                    //                    print("Saved without errors now")
                    return
                }
            } catch {
                caughtError = error as NSError
                //                print(caughtError)
            }

            saveError = caughtError

        }

        if let _ = saveError {
            throw saveError!
        }

    }

    /**
     Saves the contexts, pushing all changes to the master context and persistent store if one exists.

     - Throws: In the event of a save error, returns the NSManagedObjectContext save error.
     */
    func saveContexts() throws {

        do {

            try self.saveContext(self.partitionOp.partitionContext, fixValidationErrors: true)

        } catch {
            throw error as NSError

        }
    }

    /**
     Processes the internal context to remove objects that have been invalidated by the changes made resulting from processing.
     */
    func processValidationErrors(errors: NSError, context: NSManagedObjectContext) throws {
        // This method removes objects listed in the NSAffectedObjectsErrorKey when trying to save.

        if errors.domain == NSCocoaErrorDomain && errors.code == NSValidationMultipleErrorsError && errors.userInfo[NSDetailedErrorsKey] != nil {
            // There were multiple validation errors. Remove the objects generating the errors.
            guard let detailedErrors = errors.userInfo[NSDetailedErrorsKey] as? Array<NSError> else { return }
            for error in detailedErrors {
                guard let objectToDelete = error.userInfo[NSValidationObjectErrorKey] as? NSManagedObject else { continue }
                objectToDelete.managedObjectContext?.deleteObject(objectToDelete)

            }

        } else if errors.domain == NSCocoaErrorDomain && errors.userInfo[NSValidationObjectErrorKey] != nil {
            guard let objectToDelete = errors.userInfo[NSValidationObjectErrorKey] as? NSManagedObject else { return }
            objectToDelete.managedObjectContext?.deleteObject(objectToDelete)
        }

    }

}

